Programming Assignment 4: Parsing and fault injection
Eileen Liu | el544
Main Program: ParserFactory
Instructions:
Summary (50–300 words)
Summarize the most noteworthy aspects of the rest of your overview. Anything you mention here should be described in more detail later in the document. You might include: 
* Which parts of the assignment were the most challenging.
* Interesting design decisions that you made.
* Major issues that you ran into while designing, implementing, or testing your program.
* Known problems with your implementation, such as missing functionality or bugs.
Specification (10–500 words)
Sometimes you will need to resolve ambiguities or inconsistencies in the assignment specification.
Describe your finished specification. Identify the choices you made in finishing the specification, and provide a rationale for them. It might be useful to discuss alternatives you considered, why you rejected them, and the tradeoffs involved in your ultimate choice. If you made any changes to the given specification, justify why a change was needed and why the result of your change is reasonable.
Your job is to convince the course staff that your finished specification is reasonable and in the spirit of the assignment. If you are not convincing, the staff may deduct points.
Design and Implementation (150–1000 words)
Discuss how you created a program that satisfies the assignment specification. This includes topics such as: 
Classes:
BinaryCondition
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
BinaryConditionOperator
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
BinaryOp
* Responsibility: Represents an abstract syntax tree node that is a binary operation
* Invariant: Has two children representing the expressions to apply the binary operation to, left child is the expression left of the binary operation and right child is the expression right of the binary operation
* Interactions: Subclass of Expression, has fields of type Expression
* Algorithms:
* Data Structures: 
* Tradeoffs: 
* Author(s): Eileen, Harrison
Condition
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
Console
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
ErrorToken
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
Expression
* Responsibility: Represents an abstract syntax tree node that is an expression
* Invariant: Has no children
* Interactions: Subclass of Node, Superclass of BinaryOp
* Algorithms:
* Data Structures: 
* Tradeoffs:
* Author(s): Eileen
//FaultInjector
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
Node
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
NumToken
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
Parser
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
ParserFactory
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
ParserImpl
Program
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
Rule
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
SyntaxError
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
Token
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):
Tokenizer
* Responsibility:
* Invariant:
* Interactions:
* Algorithms:
* Data Structures:
* Tradeoffs:
* Author(s):

* Classes 
o How you decomposed the program into classes, and what the responsibility of each class is.
o Key invariants maintained by each class.
* Architecture: 
o How classes are composed and interact to accomplish the design goals. Discuss any design patterns that you have used and why you chose to use them.
* Code design: 
o What algorithms are employed in your program. We encourage you to include high-level pseudocode of any complex algorithms that you use. We also encourage discussion of any boundary conditions or formulas involved, as well as citations for sources of your algorithms.
o What data structures are employed.
o Tradeoffs you made between simplicity of code and efficiency of execution.
* Programming: 
o The implementation strategy you used—e.g., top-down, bottom-up, ...?
o Any challenges you encountered while coding.
o Any code reuse or revision you employed from previous assignments.
o Which group members wrote which parts of the code.
We used the bottom-up implementation strategy for this programming assignment. 
Your job is to give the course staff enough information that we can understand your program, without needing to look at the source code, and to convince us that you thought carefully about the construction of your program.
Testing (150–1000 words)
Though the course staff may sometimes provide some test cases for you; it is almost always a mistake to think that those test cases are complete. The course staff often has a reserve of tricky test cases that your code will be tested against. So spend time designing your own test cases. Don't wait until the last minute—do it early in the assignment, even before you've written any code.
Testing at the last minute is a recipe for failure. You should be testing your program incrementally as it is developed, starting as early as possible. 
Describe and evaluate your test plan, and discuss any interesting issues that arose during the design of your test plan. Why do you have confidence that your test cases have enough coverage of the input space, and enough coverage of your code? Do your test cases accomplish both unit testing and integration testing? Include pointers to your tests.
Describe the results of carrying out your test plan on your program. Which of your test cases pass, and which fail? If any of your tests fail, be sure to include a discussion of why you think they fail in the known problems section.
Claimed test case results that cannot be reproduced with your submitted code will be severely penalized and might even be an academic integrity violation. Never "fix up" the output of your program.
Your job is to convince the course staff that you exercised due diligence in validating your program.
Known problems (1–500 words)
Detail any known problems with your specification, design, or implementation. Problems that are clearly identified and described here will be looked upon more favorably than problems that the course staff discovers on its own. Are there bugs in your program? Missing functionality? Incorrect specifications? Incorrect documentation in the code? Let us know.
Comments (1–200 words)
Express your opinions about the assignment. This section of the overview document will not be graded, but it earns good karma. We appreciate hearing your thoughts. You might address such questions as:
* How much time did you spend on the assignment? How was it divided between designing, coding, and testing?
* What advice should we have given you before you started?
* What was surprising about the assignment?
* What was hard about the assignment?
* What did you like or dislike about the assignment?
* What would you change about the assignment?

Providing more time to complete the assignment.

